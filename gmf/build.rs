use flate2::Compression;
use flate2::write::GzEncoder;
use sha2::{Digest, Sha256};
use std::io::{self, Write};
use std::path::Path;
use std::{env, fs, path::PathBuf};
use tar::Builder;

struct AssetInfo {
    // 将在生成的 Rust 代码中使用的常量名前缀，例如 "REMOTE_ELF"
    const_prefix: String,
    // 生成的 .tar.gz 文件在 OUT_DIR 中的路径
    targz_path: PathBuf,
    // 原始文件的 SHA256 哈希值
    sha256_hex: String,
}

/// 处理本地构建的 gmf-remote ELF 文件。
/// 它会找到 ELF，将其打包成 tar，然后用 Gzip 压缩。
fn generate_gmf_remote_asset(out_dir: &Path, profile: &str) -> AssetInfo {
    let workspace_root = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap())
        .parent()
        .unwrap()
        .to_owned();

    let remote_elf_path = workspace_root
        .join("target")
        .join("x86_64-unknown-linux-musl")
        .join(profile)
        .join("gmf-remote");

    // Cargo 会在 remote_elf_path 文件变动时才重新运行此 build.rs
    println!("cargo:rerun-if-changed={}", remote_elf_path.display());

    if !remote_elf_path.exists() {
        panic!(
            "gmf-remote ELF not found at: {}. Please build the 'gmf-remote' crate first with --profile {}",
            remote_elf_path.display(),
            profile
        );
    }

    // 读取原始 ELF 文件并计算其哈希
    let original_bytes = fs::read(&remote_elf_path).expect("Failed to read gmf-remote ELF");
    let new_sha256 = Sha256::digest(&original_bytes);
    let new_sha256_hex = format!("{new_sha256:x}");

    // 缓存检查逻辑
    let targz_path = out_dir.join("gmf-remote.tar.gz");
    let sha256_marker_path = out_dir.join("gmf-remote.sha256");

    // 尝试读取上一次保存的哈希值
    let old_sha256_hex = fs::read_to_string(&sha256_marker_path).unwrap_or_default();

    // 如果哈希值未变，并且输出文件确实存在，则跳过所有生成步骤
    if old_sha256_hex == new_sha256_hex && targz_path.exists() {
        println!("cargo:info=gmf-remote executable unchanged, skipping asset generation.");
        // 直接返回信息，使用已存在的文件
        return AssetInfo {
            const_prefix: "GMF_REMOTE".to_string(),
            targz_path,
            sha256_hex: new_sha256_hex,
        };
    }

    // 如果哈希值变了或文件不存在，则执行生成流程
    println!("cargo:info=gmf-remote executable changed, regenerating asset.");

    // 将 ELF 打包进 tar 归档
    let mut tar_builder = Builder::new(Vec::new());
    let mut header = tar::Header::new_gnu();
    header.set_size(original_bytes.len() as u64);
    header.set_mode(0o755);
    header.set_cksum();
    tar_builder
        .append_data(&mut header, "gmf-remote", original_bytes.as_slice())
        .expect("Failed to append gmf-remote to tar archive");
    let tar_bytes = tar_builder
        .into_inner()
        .expect("Failed to finalize tar archive");

    // Gzip 压缩 tar 归档
    let compression_level = if profile == "release" {
        Compression::best()
    } else {
        Compression::none()
    };
    let mut enc = GzEncoder::new(Vec::new(), compression_level);
    enc.write_all(&tar_bytes).unwrap();
    let targz_bytes = enc.finish().unwrap();

    // 将压缩文件写入 OUT_DIR
    fs::write(&targz_path, &targz_bytes).expect("Failed to write gmf-remote.tar.gz");

    // 更新哈希标记文件
    fs::write(&sha256_marker_path, &new_sha256_hex).expect("Failed to write SHA256 marker file");

    AssetInfo {
        const_prefix: "GMF_REMOTE".to_string(),
        targz_path,
        sha256_hex: new_sha256_hex,
    }
}

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let profile = env::var("PROFILE").expect("PROFILE env var not set by Cargo");

    let assets = vec![generate_gmf_remote_asset(&out_dir, &profile)];

    let mut final_content = String::new();
    final_content.push_str("// This file is automatically generated by build.rs. Do not edit.\n\n");

    for asset in assets {
        let asset_content = format!(
            r##"pub const {prefix}_TAR_GZ: &[u8] = include_bytes!(r#"{path}"#);
pub const {prefix}_SHA256: &str = "{sha256}";
"##,
            prefix = asset.const_prefix,
            path = asset.targz_path.display(),
            sha256 = asset.sha256_hex
        );

        final_content.push_str(&asset_content);
        final_content.push('\n');
    }

    let embed_rs_path = out_dir.join("embedded_assets.rs");
    fs::write(&embed_rs_path, final_content).expect("Failed to write embedded_assets.rs");
}
