use flate2::Compression;
use flate2::write::GzEncoder;
use sha2::{Digest, Sha256};
use std::io::Write;
use std::path::Path;
use std::{env, fs, path::PathBuf};
use tar::Builder;

// 用于在函数间传递生成的资源信息
struct AssetInfo {
    // 将在生成的 Rust 代码中使用的常量名前缀，例如 "REMOTE_ELF"
    const_prefix: String,
    // 生成的 .tar.gz 文件在 OUT_DIR 中的路径
    targz_path: PathBuf,
    // 原始文件的 SHA256 哈希值
    sha256_hex: String,
}

/// 处理本地构建的 gmf-remote ELF 文件。
/// 它会找到 ELF，将其打包成 tar，然后用 Gzip 压缩。
fn generate_gmf_remote_asset(out_dir: &Path, profile: &str) -> AssetInfo {
    println!("cargo:rerun-if-changed=crates/gmf-remote"); // 依赖 gmf-remote crate

    let workspace_root = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap())
        .parent()
        .unwrap()
        .to_owned();

    let remote_elf_path = workspace_root
        .join("target")
        .join("x86_64-unknown-linux-musl")
        .join(profile)
        .join("gmf-remote");

    println!("cargo:rerun-if-changed={}", remote_elf_path.display());

    if !remote_elf_path.exists() {
        panic!(
            "gmf-remote ELF not found at: {}. Please build the 'gmf-remote' crate first with --profile {}",
            remote_elf_path.display(),
            profile
        );
    }

    // 1. 读取原始 ELF 文件
    let original_bytes = fs::read(&remote_elf_path).expect("Failed to read gmf-remote ELF");

    // 2. 计算原始文件的 SHA256
    let sha256 = Sha256::digest(&original_bytes);
    let sha256_hex = format!("{sha256:x}");

    // 3. 将 ELF 打包进 tar 归档
    let mut tar_builder = Builder::new(Vec::new());
    let mut header = tar::Header::new_gnu();
    header.set_size(original_bytes.len() as u64);
    header.set_mode(0o755);
    header.set_cksum();
    tar_builder
        .append_data(&mut header, "gmf-remote", original_bytes.as_slice())
        .expect("Failed to append gmf-remote to tar archive");
    let tar_bytes = tar_builder
        .into_inner()
        .expect("Failed to finalize tar archive");

    // 4. Gzip 压缩 tar 归档
    let compression_level = if profile == "release" {
        println!("cargo:warning=gmf-remote: Using max compression for release build.");
        Compression::best()
    } else {
        Compression::none()
    };
    let mut enc = GzEncoder::new(Vec::new(), compression_level);
    enc.write_all(&tar_bytes).unwrap();
    let targz_bytes = enc.finish().unwrap();

    // 5. 将压缩文件写入 OUT_DIR
    let targz_path = out_dir.join("gmf-remote.tar.gz");
    fs::write(&targz_path, &targz_bytes).expect("Failed to write gmf-remote.tar.gz");

    AssetInfo {
        const_prefix: "GMF_REMOTE".to_string(),
        targz_path,
        sha256_hex,
    }
}

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let profile = env::var("PROFILE").expect("PROFILE env var not set by Cargo");

    let assets = vec![generate_gmf_remote_asset(&out_dir, &profile)];

    let mut final_content = String::new();
    final_content.push_str("// This file is automatically generated by build.rs. Do not edit.\n\n");

    for asset in assets {
        let asset_content = format!(
            r##"pub const {prefix}_TAR_GZ: &[u8] = include_bytes!(r#"{path}"#);
pub const {prefix}_SHA256: &str = "{sha256}";
"##,
            prefix = asset.const_prefix,
            path = asset.targz_path.display(),
            sha256 = asset.sha256_hex
        );

        final_content.push_str(&asset_content);
        final_content.push('\n');
    }

    let embed_rs_path = out_dir.join("embedded_assets.rs");
    fs::write(&embed_rs_path, final_content).expect("Failed to write embedded_assets.rs");
}
